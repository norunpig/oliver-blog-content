import{_ as e,p as o,q as d,a1 as i}from"./framework-5866ffd3.js";const a={},r=i('<h1 id="模块的加载机制" tabindex="-1"><a class="header-anchor" href="#模块的加载机制" aria-hidden="true">#</a> 模块的加载机制</h1><h3 id="_1-优先从缓存中加载" tabindex="-1"><a class="header-anchor" href="#_1-优先从缓存中加载" aria-hidden="true">#</a> 1.优先从缓存中加载</h3><p><code>模块在第一次加载后会被缓存</code>。这也意味着多次调用**require()**不会导致模块的代码被执行多次。 注意：不论是内置模块、用户自定义模块、还是第三方模块，它们都会优先从缓存中加载，<code>从而提高模块的加载效率</code>。</p><h3 id="_2-内置模块的加载机制" tabindex="-1"><a class="header-anchor" href="#_2-内置模块的加载机制" aria-hidden="true">#</a> 2.内置模块的加载机制</h3><p>内置模块是由Node.js官方提供的模块；<code>内置模块的加载优先级最高</code>。 例如，require(&#39;fs&#39;)始终返回内置的fs模块，即使在node_modules目录下有名字相同的包也叫做fs。</p><h3 id="_3-自定义模块的加载机制" tabindex="-1"><a class="header-anchor" href="#_3-自定义模块的加载机制" aria-hidden="true">#</a> 3.自定义模块的加载机制</h3><p>使用require()加载自定义模块时，必须指定./或../开头的<code>路径标识符</code>。在加载自定义模块时，如果没有指定./或../这样的路径标识符，则node会把它当作<code>内置模块</code>或<code>第三方模块</code>进行加载。</p><p>同时，在使用require()导入自定义模块时，如果省略了文件扩展名，则Node.js会按顺序分别尝试加载以下的文件：</p><ul><li>按照确切的文件名进行加载</li><li>补全.js扩展名进行加载</li><li>补全.json扩展名进行加载</li><li>补全.node扩展名进行加载</li><li>加载失败，终端报错</li></ul><h3 id="_4-第三方模块的加载机制" tabindex="-1"><a class="header-anchor" href="#_4-第三方模块的加载机制" aria-hidden="true">#</a> 4.<code>第三方模块</code>的加载机制</h3><p>如果传递给require()的模块标识符不是一个内置模块，也没有以&#39;./&#39;或&#39;../&#39;开头，则Node.js会从当前模块的父目录开始，尝试/node_modules文件夹中加载第三方模块。</p><p><code>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录</code>。</p><p>例如，假设在<code>C:\\Users\\itheima\\project\\foo.js</code>文件里调用了require(&#39;tools&#39;),则Node.js会按以下顺序查找：</p><ul><li>C:\\Users\\itheima\\project\\node_modules\\tools</li><li>C:\\Users\\itheima\\node_modules\\tools</li><li>C:\\Users\\node_modules\\tools</li><li>C:\\node_modules\\tool</li></ul><h3 id="_5-目录作为模块" tabindex="-1"><a class="header-anchor" href="#_5-目录作为模块" aria-hidden="true">#</a> 5.<code>目录</code>作为模块</h3><p>当把目录作为模块标识符，传递给require()进行加载的时候，有三种加载方式：</p><ul><li>在被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为require()加载的入口</li><li>如果目录里没有package.json文件，或者main入口不存在或无法解析，则Node.js将会试图加载目录下的<code>index.js文件</code>。</li><li>如果以上两步都失败了，则Node.js会在终端打印错误消息，报告模块的缺失：Error：Cannot find module &#39;xxx&#39;</li></ul>',17),s=[r];function l(c,n){return o(),d("div",null,s)}const t=e(a,[["render",l],["__file","4.模块的加载机制.html.vue"]]);export{t as default};
